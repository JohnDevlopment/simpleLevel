.mso www.tmac
.mso pd.tmac \" Project Dewpsi macros
\" Manual page for the Project Dewpsi game engine.
.TH "Project Dewpsi" 7 "11/15/19" "Beta Build" "Project Dewpsi Development Manual"
.
.SH NAME
Project Dewpsi \- official Project Dewsi game engine (beta)
.
.SH DESCRIPTION
.PP
This manual covers the underlying engine of \fBProject Dewpsi\fP.
The engine is split into seven major systems: video, sound, input, \
gamemodes, objects, logging, and scripting.
.
.SS VIDEO
.PP
The video system is responsible for the rendering of graphics.
The functions are encapsulated within the namespace \fBvideo\fP.
.TP
.B Graphics State
The video system keeps track of what\(aqs being drawn on the screen, as well as the current \
position of the camera, etc., in a data construct that represents the state of the engine.
Anytime the video engine is paused via \fBvideo::Pause\fP, a "snapshot" is taken of the current \
state of the engine.
And when the video engine is resumed, this "snapshot" is used to revert the state of the engine.
.
.IP "video.cc/video.h"
Functions in namespace
.B video\c
\~are separated into different source files, sorted by their relative purpose.
For example, video.cc implements all the actual draw and update processes, while textures.cc \
contains functions that load graphics from files. Functions starting here belong to video.cc \
and video.h.
.
.FA void SetBgColor "const JColor&" color
Changes the background color to the values listed in \fIcolor\fP. \c
Also changes the state of the graphics engine to reflect this change.
.FA void SetRenderer SDL_Renderer* ren
Saves \fIren\fR to the graphics engine so that it can later render graphics.
.FA SDL_Renderer* GetRenderer
Returns the rendering context that was passed to
.B SetRenderer.
.FA void Init int width int height SDL_Renderer* ren
Initializes the video engine, supplying it with the width and height of the screen \
as well as a pointer to the rendering device which will be used to draw elements \
to the screen.
It is only valid to call this function once.
.FA void Update
Draws every component to the screen.
The world components are drawn first, then the HUD components.
Then the changes are presented to the screen.
.FA void RegisterWorldComponent PDGfxComponent* pComp
Registers a component to be drawn in the game world.
.FA void RegisterHUDComponent PDGfxComponent* pComp
Registers a component to be drawn on the HUD.
.FA void UnregisterComponent PDGfxComponent* pComp
Removes the given component from the video component lists.
.FA void ClearComponents
Removes all components from video system.
.FA void Pause bool drawPaused
Pauses the video engine.
Saves the current state of the engine to be later restored with a call to
.B Resume.
.FA void Resume
Restarts the video engine and restores the previously saved graphics state.
.FA void Draw PDTexture* texture int* pXY
Draws the given texture to the screen.
.I pXY
is NULL if omitted. \c
Otherwise it is a pointer to an array with two integers denoting the X & Y position that the \
texture should be drawn at.
.
.IP "textures.cc/textures.h"
The loading and modification of textures, the game\(aqs primary way of representing graphics, \
are handled in this file.
.
.FA SDL_Texture* LoadTexture SDL_Renderer ren "const char*" file "const uint32_t*" colorkey
Constructs a texture based off of the image data in
.I file\c
\&.
.I ren
is used to get information on the screen and create a hardware-specific representation of image data.
.I colorkey\c
\&, if omitted, defaults to NULL and consequently has no effect.
But if it is provided, it points to an integer of the format \f[I]RRGGBB\f[R]FF, where
RR is a red value between 0 and 255, and GG and BB are the green and blue values respectively.
Every pixel of that color will be transparent in the created texture.
.
.FA SDL_Texture* LoadTexture "const char*" file "const uint32_t*" colorkey
Synonomous with \fBLoadTexture\fP up above, with the exception that it does\(aqt require \
an SDL_Renderer.
Only works if \fBSetRenderer\fP was called beforehand.
.
.FA TexMov_t* NewTexMov "const char*" file "const uint32_t*" colorkey
Loads an image file, \fIfile\fP, an constructs a TexMov_t based off of its data.
\fIcolorkey\fP points to an integer of the format described above in \fBLoadTexture\fP; \
it can be omitted, in which case it has no effect.
But if \fIcolorkey\fP is provided it causes every pixel of that color to be drawn transparent.
.
.IP "camera.cc/camera.h"
Functions that set, reset, query, and modify the two types of cameras used in the game: they are referred to \
as the world perspective and the HUD perspective.
.
.FA void SetToWorldPerspective
Switches to the world perspective.
.FA void SetWorld int w int h
Sets the dimensions of the world.
.FA void SetToHUDPerspective
Switches to the HUD perspective.
.FA void SetHUD
Sets the dimensions of the HUD region
.FA SDL_Rect* GetCamera
Returns the currently active camera.
.FA void SetCameraPos int x int y
Sets the position of the active camera to \c
.IR x " and " y .
.
.SS "GAMEMODE MANAGER"
.PP
.B PDGamemodeManager
is a singleton class that manages all gamemodes.
A gamemode is a section of the game\(aqs code, such as when the splash screen is displayed, \
or when the title menu is up.
.PP
All the functions in this class are static, so there is no need to make an object of it.
To use this manager, call
.B Init
to get initialize the game manager.
.B SetFirstGamemode
is called somewhere at the beginning of the program, after the manager is \
already initialized, to set the initial gamemode.
.B Update
is called in the game loop to update the state of an active gamemode.
Shutdown is used somewhere near the end of the program to free all resources \
associated with the manager.
After that point the manager cannot be used.
.PP
This class has private methods.
Those methods can be freely accessed by class
.B PDApp\c
\&.
.
.FA "static void" InitGamemode
.PRIVATE
Initializes the current gamemode according to several flags.
Called at the beginning of \fBUpdate\fP.
.FA "static void" ChangeGamemode
.PRIVATE
Switches to a different gamemode.
Called at the end of \fBUpdate\fP.
.FA "static void" Init "const PDGameData&" srcData
.PRIVATE
Initializes the gamemode manager with the information found in
.I srcData\c
\&.
This function must be called before any other.
.FA "static void" Update
.PRIVATE
Starts up and continues execution of the current gamemode.
This function initializes a loop that helps with executing the code.
.FA "static void" Shutdown
.PRIVATE
Deactivates the gamemode manager.
It cannot be used after this is called.
.FA "static bool" IsQuitting
Returns true if the gamemode manager is quitting.
.FA "static bool" IsRestarting
Returns true if the manager is restarting a gamemode.
.FA "static PDGameData&" GetGameData
Returns the shared game data.
.FA "static void" AddGamemode PDGamemodeType type PDGamemodeBuilder* builder
Adds a gamemode builder to the factory.
.I builder
should return a class derived from PDGamemode.
You can then build the gamemode marked by
.I type
by calling
.BR SetFirstGamemode ", " SetNextGamemode ", and " PauseAndChangeGamemode .
.FA "static void" RemoveGamemode PDGamemodeType type
Removes the specified gamemode from the manager.
.FA "static void" ClearGamemodes
Removes all gamemodes from the manager.
.FA "static void" SetFirstGamemode PDGamemodeType type
Call this function only once near the beginning of the program.
Sets the initial gamemode.
.FA "static void" SetNextGamemode PDGamemodeType type
Sets the next gamemode.
.FA "static void" PauseAndChangeGamemode PDGamemodeType next bool drawPaused
Pauses the active gamemode and loads a different one specified by \fInext\fR.
If
.I drawPaused
is true, the objects being drawn to the screen will still be drawn even after pausing \
the gamemode.
.I drawPaused
defaults to false if omitted.
.FA "static void" Resume
Resumes the previously paused gamemode.
Should be called an equal number of times that
.B PauseAndChangeGamemode
was called.
.
.SS "OBJECT MANAGER"
.PP
.B PDObjectManager\c
\~is a singleton class that manages all the objects in the game.
For the purposes of this engine, an object refers to any \%
self-contained piece of code \
that can move itself across the screen.
In order to use this class you first have to call \c
.B PDObjectManager::Init.
And before the program ends, after you\(aqve finished using it, you must call \c
.B PDObjectManager::Shutdown\c
\~to free up the objects in memory that were used by the manager.
.PP
After the initialization stage, you should call \c
.B PDObjectManager::Update\c
\~once per frame to update the objects in a gamemode. \c
It should not be neccessary, as it is done during initialization, but you may \c
add new object prototypes \c
.SM "(see below)"\c
\~and add new component types to the manager.
Project Dewpsi uses what is known as a factory to build components while objects \
are created using prototypes.
.
.FA "static void" Init
.PRIVATE
Initializes the object manager.
The object manager holds a list of created objects in a \fBstd::vector\fP.
The vector preallocates some space so that memory allocation isn\(aqt done excessively.
Another vector holds a list of object prototypes\(emeach prototype is associated with an \
enumerated key in a hash table.
A factory holds a list of component builders; a function registers each builder with a \
numeric ID in a hash table.
With this the object manager can now update, add and remove objects from its internal list.
.FA "static void" Shutdown
.PRIVATE
Shuts down the object manager by deleting all the objects and object prototypes in the manager.
.FA "static void" Update
.PRIVATE
Updates every object.
If an object is marked as "dead", it gets deleted and removed from the object list.
.
.SS LOGGING
.PP
The logging system handles various I/O operations, particularly involving predefined log files.
In order to use these functions, all you have to do is call \c
.B Log_Init
at the start of the program.
There is no shutdown function as this system will clean itself up \
automatically.
.
.FA void Log_Init
Initializes the logging system.
All it does is open two files for writing: by default they are cout.txt for normal status messages \
and cerr.txt for errors that do not get put out to standard error.
After this \c
.BR Log_Cout " and " Log_Cerr
can be used.
.FA void Log_Error "const char*" fmt args
Synonomous with printf.
.FA void _Log_Assert "const bool" expr "const char*" msg "const char*" func "const char*" file "unsigned int" line
.B Warning:
this function is not meant to be used directly.
Please use \fBLog_Assert\fR instead.
Tests
.IR expr ,
printing a message that includes
.IR msg ", " func ", " file ", and " line ,
should the expression return false, and also aborting execution of the program via abort.
.FA void _Log_Test "const bool" expr "const char*" testname
Prints whether \fIexpr\fP evaluates to true or not using \fItestname\fP as part of its message.
As with _Log_Assert, it is not recommended that you use this function directly but use
.B Log_Test
instead.
\" macros
.MACRO Log_Assert expr msg
.DEBUG
Tests whether
.I expr
is true and aborts execution with
.I msg
printed to stdout if it\(aqs false.
.MACRO Log_Test expr
.DEBUG
Tests \fIexpr\fR and prints whether that expression returns true.
.MACRO Log_Print expr
Prints the string
.I expr
and then prints the value it evaluates to.
.MACRO Log_printf fmt ...
.DEBUG
This macro expands to printf, so the arguments are the exact same.
.
.SH BUGS
.PP
This build has not yet been bug-tested, so bugs have not been found.
.
.SH AUTHOR
.PP
All code was written by John Russell.
However, the object manager, gamemode manager, factory class, object class, and all other related code were \
written with the advice gotten from \c
.URL "https://www.packtpub.com/game-development/game-development-patterns-and-best-practices" \
"Game Development Patterns And Best Practices" ", which was published by Packt Publishing Limited."
.
.SH "SEE ALSO"
.BR PDTexture "(7), " TexWrapper_t "(7), " TexFader_t "(7), " TexMov_t "(7), " PDInifile (7)
